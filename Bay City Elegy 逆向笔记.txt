Bay City Elegy 逆向笔记

文本内容在 Bay City Elegy\YOKOHAMA\RB_MES 目录下各 MES 文件中

文本采用单双字节混合压缩，比如

山崎「姐さんがいっていた通りだゼ……コイツ、まったく
   クチをきこうとしないゾ」
=
8E 52  山
8D E8  崎
81 75  「
88 B7  姐
41  さ
7F  ん
38  が
30  い
4F  っ
52  て
30  い
4B  た
92 CA  通
76  り
4C  だ
83 5B  ゼ
81 63  …
81 63  …
83 52  コ
83 43  イ
83 63  ツ
81 41  、
6A  ま
4F  っ
4B  た
3B  く
A5  换行？
81 40  空格
81 40  空格
81 40  空格
83 4E  ク
83 60  チ
7E  を
39  き
3F  こ
32  う
54  と
43  し
56  な
30  い
83 5D  ゾ
81 76  」

其中，汉字和「」、符号是双字节 sjis 编码
平假名是单字节编码，比如 さ
片假名是双字节 sjis 编码，比如 ゼ コ
目前推测换行是单字节 A5

30: い (0x30)
32: う (0x32)
38: が (0x38)
39: き (0x39)
3B: く (0x3B)
3F: こ (0x3F)
41: さ (0x41)
43: し (0x43)
4B: た (0x4B)
4C: だ (0x4C)
4F: っ (0x4F)
52: て (0x52)

=====================================================================================================
结论1：
从第一个平假名 a 开始，它的编号是 0x2D，到最后一个平假名 n 结束 0x7F（已实验证实）
原理是 (82, 72 + x)，范围是 829F-82F1
=====================================================================================================

sjis 编码范围：81-9F E0-EF
中间还有 A0-DF 的空白，其中 A5 作为换行符存在

测试 A0-A4 均报错，A5 不报错，换行，A8 不报错，意义未知

81 A4 = ▽ 很特殊，经常作为单行对话符出现
81 A2 = △ 也是

上句话结束到下句话开始之间有以下字节
AB AA 23
确认插入后会有在当前结束语句打印，等待触发下一句后再打印后续文本的效果

AB = 中断并等待下一句 UI 输入信号，但是不会抹除已有的文字
AA = 清除当前对话框文本并把光标重定向到首部
23 = 未知

AA 23 观察到这两个是一直在一起的，包括第一句对话前
推测 AB 是结束符，AA 23 是开始符

=========================================================================================================================
正则描述：
\xAA\x23([\x81-\x9F\xE0-\xEF][\s\S]|[\x2D-\x7F]|[\xA5])+\xAB
\xAA\x23(\xC5\x23\x28\x10\xC3\x24\x2C\x7F\x7F){0,1}([\x81-\x9F\xE0-\xEF][\s\S]|[\x2D-\x7F]|[\xA5])+\xAB
\xAA\x23(\xC5\x23\x28\x10\xC3\x24\x2C\x7F\x7F){0,1}([\x81-\x9F\xE0-\xEF][\s\S]|[\x2D-\x7F]|[\xA5\x21\x00]|\x0C[\s\S])+\xAB
\xAA\x23(\xC5\x23\x28\x10\xC3\x24\x2C\x7F\x7F){0,1}([\x81-\x9F\xE0-\xEF][\s\S]|[\x2D-\x7F]|[\xA5\x21\x00]|\x0C[\s\S]|\x20\x00)+\xAB

\xAA\x23(\x21\x28\x00[\s\S]{2}\x21\x29\x00|\x21\x20\x00[\s\S]{2}\x21\x20\x00){0,1}([\x81-\x9F\xE0-\xEF][\s\S]|[\x2D-\x7F]|[\xA5\x21])+\xAB
\xAA\x23([\x81-\x9F\xE0-\xEF][\s\S]|[\x2D-\x7F]|[\xA5]|\x21[\s\S]+?\x00)+\xAB
\xAA\x23([\x81-\x9F\xE0-\xFC][\s\S]|[\x2D-\x7F]|[\xA5]|\x21[\s\S]+?\x00)+\xAB

[\xCE\xCF][\s\S]{2}|\xCD([\x29-\x2C][\s\S]{2}|\x28[\s\S]|[\x23-\x27]){1,}(\x22[^\x22]+\x22){0,1}|\xAA\x23([\x81-\x9F\xE0-\xFC][\s\S]|[\x2D-\x7F]|[\xA5]|\x21[^\x00]+\x00)+\xAB

[\xCE\xCF][\s\S]{2}|\xCD([\x29-\x2C][\s\S]{2}|\x28[\s\S]|[\x23-\x27]){1,}(\x22[^\x22]+\x22){0,1}|\xAA\x23(\xC5([\x23-\x27\x29-\x2C]|\x28[\s\S]){2}){0,}([\x81-\x9F\xE0-\xFC][\s\S]|[\x2D-\x7F]|[\xA5]|\x21[^\x00]+\x00)+

\xAA\x23([\xC3\xC5]([\x23-\x27]|\x28[\s\S]|[\x29-\x2C][\s\S]{2}){2}){0,}([\x81-\x9F\xE0-\xFC][\s\S]|[\x2D-\x7F]|[\xA5]|\x21[^\x00]+\x00)+|[\xCE\xCF][\s\S]{2}|\xCD([\x29-\x2C][\s\S]{2}|\x28[\s\S]|[\x23-\x27]){1,}(\x22[^\x22]+\x22){0,1}

\xAA\x23([\xC3\xC5]([\x23-\x27]|\x28[\s\S]|[\x29-\x2C][\s\S]{2}){2}|\xD0\x73\x65(\x20){0,}(\x22[^\x22]+\x22|[^\x22]([\x23-\x27]|\x28[\s\S]|[\x29-\x2C][\s\S]){0,1})){0,}([\x81-\x9F\xE0-\xFC][\s\S]|[\x2D-\x7F]|[\xA5]|\x21[^\x00]+\x00)+|[\xCE\xCF][\s\S]{2}|\xCD([\x29-\x2C][\s\S]{2}|\x28[\s\S]|[\x23-\x27]){1,}(\x22[^\x22]+\x22){0,1}

选项的正则:
\x81\x77([\x81-\x9F\xE0-\xFC][\s\S]|[\x2D-\x7F]|[\xA5]|\x21[^\x00]+\x00)+\x81\x78

对应只选文本的正则：
\xAA\x23([\xC3\xC5]([\x23-\x27]|\x28[\s\S]|[\x29-\x2C][\s\S]{2}){2}|\xD0\x73\x65(\x20){0,}(\x22[^\x22]+\x22|[^\x22]([\x23-\x27]|\x28[\s\S]|[\x29-\x2C][\s\S]{2}){0,1})){0,}([\x81-\x9F\xE0-\xFC][\s\S]|[\x2D-\x7F]|[\xA5]|\x21[^\x00]+\x00)+|\x81\x77([\x81-\x9F\xE0-\xFC][\s\S]|[\x2D-\x7F]|[\xA5]|\x21[^\x00]+\x00)+\x81\x78

=========================================================================================================================


其它前缀：
AA 23 (C5 23 28 10 C3 24 2C 7F 7F) 对话
其它单字节
21: !		比如，愛音「――!!!	纠正，这里第一个 21 是转义，后面的两个 21 是 !，会有 00 结束
00: 转义结束符	
0C: ?		出现在 MES06.MES
01: ?		出现在 MES06.MES
0C 01
0C 04		猜测 0C 是一个调用，后面跟一个参数比如 01 或 04

AA 23 21 28 00 90 BA 21 29 00
28 00	(
29 00	)
这是一种人名，比如 (声)，推测以 28 00 开始 29 00 结束

=====================================================================================================
观察1：
21 28 00 90 BA 21 29 00 是一种固定形式，对应人物 (声)，总共出现在 3 个文件中 21 次
=====================================================================================================

准确讲，是 21 28 00 XX ... XX 21 29 00，是一种普遍出现的 (XX) 形式，常用于开始的人名

类似的还有 21 20 00 XX ... XX 21 20 00，是在文字前后加两个空格

=====================================================================================================
结论2：
21 28 00 XX XX 21 29 00		对应 "(单)"
21 20 00 XX XX 21 20 00		对应 " 单 "
是两种人名给出方式，位于 AA 23 之后
=====================================================================================================


AA 23 (A7 28 0C 29 02) 5A 81 40 81 40 81 40 81 40
81 40 81 40 81 40 81 40 81 40 81 40 21 20 00 81
73 81 5C 8C BB 8D DD 81 5C 81 74 CD 29 02 00

有的文本不一定以 AB 结尾，或者说还是以 AB 结尾，但是文字后加了大量参数，包括指定各种文件路径。MSG06.MES 的 "现在" 开始就是这种

还有一些选项，它是不被匹配的

对 MSG06.MES
21 21 21 00 81 76 A5 81 A2 81
的实验，观察如下

21 21 21 00 => !! 正常回车
30 31 32 00 => 平假名 iUu，正常回车
21 30 31 32 => 012，没回车
21 30 31 00 => 01 正常回车

说明 21 作为前缀的时候后面的 30 作为 ascii 码 0 解析，没有 21 前缀时采用平假名区间 2E-80 解析
说明 00 是结束 21 的生效区间

得出结论
=====================================================================================================
结论3：
21 XX ... 00 是一种转义区间
21 表示开启 ASCII 码解析
00 表示结束 ASCII 码解析
=====================================================================================================

结论3 可以解释 结论2 的现象，结论2 复述
21 28 00 XX XX 21 29 00		对应 "(单)"
21 20 00 XX XX 21 20 00		对应 " 单 "
本质都是两处小 ascii 码区间加在首尾，21 28 00 表示 (，一个是 21 29 00 表示 )，21 20 00 表示 " "，它可被结论3 统一

一段文字不一定以 AB 结尾
比如 MSG06.MES 的
AA 23 21 28 00 90 BA 21 29 00 81 75 81 5C 81 5C
97 49 81 41 3F 4D 75 7E 40 75 7F 56 41 30 81 76
A5 81 A2
它是选项前的文本
包括后面同文件也有很多例子，这些都是文字结束后出现选项前


对比
10 00 01 81 97 FF FF 10 28 02 81 97 CD 29 3F 40 28 0B 28 27 28 3A 28 0B 26 23 23 A6 28 0C 29 02 3C 28 43 29 03 0A
10 00 02 81 97 FF FF 10 28 03 81 97 CD 29 3F 40 28 0B 28 27 28 3A 28 0B 26 23 23 A6 28 0C 29 02 3C 28 43 29 03 0A
10 00 03 81 97 FF FF 10 28 04 81 97 CD 29 3F 40 28 0B 28 27 28 3A 28 0B 26 23 23 A6 28 0C 29 02 3C 28 43 29 03 0A

10 00 XX
XX XX FF FF
0C XX
10 28 04

10 XX XX
0C XX

\xAA\x23\xA7\x28\x0C\x29\x02\x5A 这是很多时间地点介绍语句的前缀
基本上多个 81 40 后开始文本
\xAA\x23\xA7\x28\x0C\x29\x02\x5A[\s\S]+?\x29\x02 这是匹配完整范围的正则


MAME 2C00 = np21.S08 5356
np21 - MAME = 2756h
555FE - 2756 = 52EA8

MAME 52EA8 = np21.S08 5ACE8
np21 - MAME = 7E40h
555FE - 7E40 = 4D7BE ✔

找到一处 AA 23 的 AA 地址，下读写断点
wp 4D7BE,1,rw
然后断在 52666
```
mov ax,[si]
```
此时 ES = 4455, SI = 926D
所以 [si] = [44550 + 926D] = [4D7BD]
因为读的是 AX，所以是一个 word，对应的值是 AB AA
其中断的目标 4D7BE 刚好落在第二字节上，所以命中

bp 52666
观察这个位置每次读取后的值

交换 AH, AL，即 AX = AAAB => ABAA, AH = AB, AL = AA，将 AX 的值从反阅读顺序到同阅读顺序 AB AA
si += 2		指针自增 2 步
ax == FFFF?	goto 5267F
ax == FFFE?	goto 5267F
ah < A0?	goto 52680
al >= A5?	goto 52680
si -= 1

可见特殊 OP
FF FF
FF FE
范围出发
< A0 或 >= A5

AB >= A5，所以 goto 52680
52680	call 537CAh

proc 537CAh	文字区字节解析逻辑，是 sjis 文字则进位标志设 0 后返回，不是 sjis 则进位标志设 1 后返回
ah <= 80?	goto 537DE
ah <= 9F?	goto 537E0
ah < E0?	goto 537DE
ah <= FC?	goto 537E0
很明显的日语 sjis 首字节判断，和 80 以内单字节映射平假名判断
根据信息，修正 sjis 字节范围为 [\x80-\x9F\xE0-\xFC]

两个跳转点 537DE 和 537E0 的区别
537DE: STC; RET		CF = 1	进位标志设 1
537E0: CLC; RET		CF = 0	进位标志设 0

后续有一条 jb 526DB 指令，它是 CF == 1 时满足，否则不满足
因此，不是 sjis 文字的，这里会满足 goto 526DB

是 sjis 文字的情况下，则不会跳走，继续执行 52685 如下：
ax == 8197?	goto 52626
ax != 8190?	goto 52698

执行 bios 中断 int(F1, ah=7)
功能是从键盘缓冲区读取一个字符，这跟按回车继续对应上了


不是 sjis 文字的情况下，goto 526DB
AH == 21?	goto 5273C		是否进入 ascii 转义逻辑
bl = ah		(= AB 当前字节)
bl = bl & F0	(AB & F0 = A0，取当前字节左半字节)
bl == 0?	goto 5271A
bl == 10?	goto 52720
si -= 1

ah == A5?	goto 52726
ah < 2D?	goto 52708
ah > 7F?	goto 52708
ah += 72, al = 82
(ah, al) = (82, al + 72)	就是 sjis = (82, 当前字节 + 72)
jmp 526C6

这里的逻辑跟之前的分析有不少对应
判断 AH == 21,是为了进入转义，根据结论3，21 XX ... 00 是 ascii 转义解析，因此 5273C 是处理这个的
判断当前字节是 0X 形，分支处理，未知
判断当前字节是 1X 形，分支处理，未知
判断当前字节是 A5，这是换行字节
判断当前字节，如果在 [2D, 7F] 范围之外，进入 52708，这跟结论 1 对应，就是在判断是否进入单字节平假名解析逻辑，后面的代码 (82, al + 72) 更印证这一点

526C6
dx = ax
int(F6, AH = 9)

52708
ah -= A6		(AB - A6 = 05)
bx = DB5A + ah * 2	(bx = DB5A + 05h * 2 = DB64)
call [bx]		(调用 5 号函数 DS * 10 + DB64 = 44550 + DB64 = 520B4，从 520B4 读到 word = E339，然后 CS * 10 + E339 = 4455- + E339 = 52889)

这里从 44550 + DB5A 对应的 0 号函数开始，函数地址表
00	E2A6
01	E2DA
02	E2EF
03	E30D
04	E320
05	E339
06	E34C
07	E35D
08	E749
09	E83C
0A	E8BE
0B	E96B
0C	E98D
0D	E9B7
0E	E9C7
0F	E9D9
10	E9EC
11	EA30
12	EA82
13	EA99
14	EAB0
15	EAC3
16	EAEC
17	EB03
18	EB0E
19	EB37
1A	EBCD
1B	EC5B
1C	EC77
1D	EC85
1E	EC93
1F	ECAB
20	ECBE
21	ECDA
22	ED1F
23	ED37
24	EFD2
25	F07F
26	ED4B
27	ED9C
28	EE18
29	EE30
2A	EE73
2B	EF0C
2C	EF93
2D	EFC5
2E	EC46
2F	E238

F092 F092 F092 0000 0000 0000 0000 0000

所以函数表对应的字节是 A6-D5
比如 C0 => C0 - A6 = 1A => EBCD => 44550 + EBCD => 5311D

AB 是中断文字流并等待键盘输入，这里对应 AB - A6 = 05，进入 5 号函数，位置是 52889
52889
53684() == 0 ? 
	int(F1, AH = 7) : 
	cx = ax; 53684(); int(F1, AH = 8)


proc 53684
push cx
al = [si]	读取下一个字节给 al (比如当前字节 AB，读到下一个是 AA)
al < 23?	goto 536CC
al > 2C?	goto 536CC	所以这里筛选下一字节 al = [23, 2C] 的区间再继续
si += 1
al >= 28?	goto 5369F	下一字节位于 [23, 2C] 时，指针自增，该字节 [28, 2C] 时走 5369F,[23, 27] 继续
al -= 23	[23, 27] 时让 ax = 00 x-23
ah = 0
cx = 1
test cx,cx	这里在更新零标志位，关系到后面 53684() == 0 的判断，如果顺着走到这里，那么零标志位为 0，不满足判断
pop cx
ret

其中的 [23, 27] 分支走 53694
ax = (00, [23, 27] - 23); return 1

其中的 28 分支
al = [si]
si += 1
ah = 0
cx = 1
test cx,cx
pop cx
ret	// return 1
即 ax = [00, [下一字节]]; return 1

其中的 [29, 2C] 分支走 536AA
cx = [si]
ch ↔ cl
si += 2
cl *= 2
ch /= 2
rcr cl, 1
al -= 29
al *= 7
ah = al
al = 0
cx = 1
test cx,cx
pop cx
ret	// return 1
ax = [ ax 和后 2 个字节决定 ]; return 1

其中的非 [23, 2C] 分支走 536CC
ax = FFFF
cx = 0
pop cx
ret	// return 0	这个分支，决定了零标志位为 1，关系到 53684() == 0? x : y，走 x 判断，即 int(F1, AH=7)
没有使用包括自己在内的字节; return 0


接下来，读取 4D7BE 内容的断点端在 52641
可在 52643 下断点看到读取后的内容
bp 52643，第二个观察口

52643
当前字节 != al	goto 52663	(这里当前字节 AA，al == 81,所以不等于，触发跳转)

52663
pop si		(这里弹栈获得的 si 没变)
ax = [si]	ax = 当前字节 下一字节	（这里读到 AA 23,所以 AX = 23AA）
ah ↔ al	AX = 23AA => AX = AA23，AH = AA, AL = 23
si += 2		指针自增 2 步
可以看到，这里包括后续重复了之前分析过的一整套流程（52666）

=========================================================================================
完整流程再总结（52666）

一次性读 2 个字节，指针 += 2：
分支-2：FFFF
分支-1：FFFE
分支1：AH 不属于 [A0, A4], goto 52680
分支2：AH 属于 [A0, A4]，指针 -= 1
ret

分支1：当前字节 不属于 [A0, A4], goto 52680，再细分
分支1.1：当前字节 属于 [/x80-/x9F/xE0-/xFC]，即 sjis 区间
分支1.2: 当前字节 <= 80 或 A0-DF，即非 sjis 区间
两个分支结束回到同一地方，不同的是 sjis 分支后续会判断 ax == 8197/8190/816F/8170 再相应处理

分支1.2: 当前字节 (, 80] U [A0, DF] - [A0, A4] 的非 sjis 区间
分支1.2.1：当前字节 == 21，进入 ascii 转义逻辑
分支1.2.2：当前字节的左半字节是 0，即 0X 形
分支1.2.3：当前字节的左半字节是 1，即 1X 形
分支1.2.4：当前字节 == A5
分支1.2.5：当前字节属于 [2D, 7F] 区间，即真正的平假名区间
分支1.2.6：当前字节其它情况，即 20,22-2C,80,81-9F,A6-DF		进入 52708，这是一个函数表，根据编号进入执行对应函数

分支1.2.6：字节属于其它情况，只讨论 A6-DF 的情况，属于大于 A6 进入函数表的情形
都会调用 53684 读取下一字节
1.2.6.1：下一字节属于 [23, 27]		x:y => y	ax = (00, 下一字节 - 23)
1.2.6.2：下一字节等于 28		x:y => y	ax = (00, 下一字节?)
1.2.6.3：下一字节属于 [29, 2C]		x:y => y	ax = (复杂计算, 00)
1.2.6.4：下一字节在 [23, 2C] 之外	x:y => x	ax = FFFF


特殊字节归纳
FF FF
FF FE
81-9F、E0-FC
2D-7F
21
A5
0X
1X

AA,AB 都是属于 1.2.6 提到的其它情况，进入函数表
对于 AA 23 来说，读取 AA 后
	因为 AA 不是 [A0, A4]，所以进入分支1
	因为 AA 不是 sjis，所以进入分支1.2
	因为 AA 属于非 sjis 的其它情况，即不是 21,0X,1X,A5 和 [2D, 7F] 区间，所以进入分支1.2.6
	因为 AA 的下一字节 23 属于 [23, 27]，所以进入分支 1.2.6.1
		结果：int(F1, AH=23)
		执行完后，跳转 52626，指针自增了 2，AA 23 21 从指向 AA 改到 21
		一通操作后回到 52643，OP 循环点之一，52643 会让当前字节跟 al 比较（al 两次看到是 81，有时是 96），不等于时跳到 52663，大 OP 循环的起点

对于 AB AA 来说，读取 AB 后
	同样属于分支1.2.6，所以读取下一字节 AA，判断 AA 属于 1.2.6.4，所以 ax = FFFF，调用 int(F1, AH=7)
		结果：int(F1, AH=7)
		执行完后，处于等待键盘或鼠标交互状态


对于 A4 10 来说，读取 A4 后
	因为 A410 不是 FFFF，也不是 FFFE，但属于 [A0-A4]，所以进入分支2
		分支2 是 si -= 1 然后 return
		return 后发现原来大循环是属于 call 52626 内部，原来 52626 是一个函数
		跳出后 al = 0 然后 return
		这时只有 ah = A4 记录当前字节
		return 后发现它 call 52BF9
		跳出后 test al 是否为 0，走这个逻辑的当然为 0，故触发跳转 5304B
		跳转 5304B 后，pop si，就是弹栈改变指针，这里从 9352 => 9061，指针倒退
			从指向 81 A2 (A4) 10 02，到指向 A2 (10) 02 00 81 97 D1 23 26 A6 23 23 28 4F 29 03
			新位置在所有文本块之前

5304B	A0-A4 区间进入
pop si
dx = A2A3
call 53652
ret

指针改为 A2 (10) 02 00 81 97 D1 23 26 A6 23 23 28 4F 29 03 的 10
[D024] = 1
al = 当前字节	(即 10)
当前字节 == dh?	goto 53671	(这里 dx = A2A3，所以 == dh 不满足，但 != dl 满足)
当前字节 != dl?	goto 53677
[D024] -= 1
[D024] == 0?	goto 5367D
jmp 5365E	即回到 al = 当前字节这一步

可见这里是个循环
5365E 读取当前字节
1. 当前字节 == dh
	53671
	[D024] += 1
2. 当前字节 != dh 且当前字节 != dl
	53677
	指针 -= 1
	call 53773
	跳回 5365E 读取字节
3. 当前字节 == dl
	[D024] -= 1
	if [D024] == 0 跳转 5367D
		5367D
		ret 结束函数
	else 即 [D024] != 0
		跳回 5365E

[D024] = 1
while(true) {
	读取当前字节
	指针 += 1
	if (当前字节 = dh) {
		[D024] += 1
	} else if (当前字节 == dl) {
		[D024] -= 1
		[D024] == 0 ? return : continue
	} else {
		指针 -= 1
		53773()
	}
}

观察到 (10) 02 00 81 97 D1 23 26 A6 调用 53773 后，SI 指针自增了 3，回到循环起点后又读了一个字节，这次是
10 02 00 (81) 97 D1 23 26 A6，指向 81

proc 53773
进入前 push ax，出去前 pop ax，所以此函数不会改变 ax
指针 += 1
cx = 1
al = 0
ah == 21?	goto 537C0
al = 22
ah == al?	goto 537C0
ah < 23?	goto 53793
ah >= 28	goto 53793
ret

53793
ah == 28?	goto 537BC
ah < 29?	goto 537A8
ah >= 2D?	goto 537A8
指针 += 1
cx += 1
goto 537BC

537A8
al = ah
al = al 的左半字节 XY => X0
al == 0?	goto 537BC
al != 10?	goto 537B7
指针 += 1
goto 537BC

537B7
call 537CA
jb 537BE，即进位标志位 1 的时候 ret

537BC
指针 += 1
cx += 1
ret

537C0
ah = [指针]
指针 += 1
cx += 1
ah == al? ret : 循环 537C0

当前字节 = 81 进来的时候，会进入 537B7 的 call 537CA 然后 ret 或继续 537BC 的逻辑
	它没有满足进位标志为 1，所以继续 537BC，指针 + 1，然后 ret
	进入 53773 函数后指针自增了 2 次，所以 10 02 00 (81) 97 D1 23 26 A6 => 10 02 00 81 97 (D1) 23 26 A6


proc 53652
10 02 00 81 97 D1 23 26 A6 23 23 28 4F 29 03 0F AA 24 D1 24 CD 29 3F 40 28 0B 28 27 28 3A 28 0B
26 23 23 A6 28 0C 29 02 3C 28 43 29 03 0A AA 23 A7 28 0C 29 02 5A 81 40 81 40 81 40 81 40 81 40
81 40 81 40 81 40 81 40 81 40
H=10 (开始)
         H=81 (+3)
		  H=23 (+1)
		     H=26 (+1)
			H=A6 (+1)
			   H=23 (+1)
			      H=23 (+1)
				 H=28 (+1)
					H=29 (+2)
H = AA (+3)
H = 24 (+1)
H = D1 (+1)
H = 24 (+1)
H = CD (+1)
H = 29 (+1)
H = 28 (+3)
H = 28 (+2)
H = 28 (+2)
H = 28 (+2)
H = 26 (+2)
H = 23 (+1)
H = 23 (+1)
H = A6 (+1)
H = 28 (+1)
H = 29 (+2)
H = 28 (+3)
H = 29 (+2)
H = AA (+3)

AA 23 这里是消除文字的作用
注意到这里 DX 是 A3A2，仍然不匹配

H = 23 (+1)
H = A7 (+1)
H = 28 (+1)
H = 29 (+2)
H = 81 (+3)

......

一直走到（从 MSG06.MES 的 61h，刚好在 60h 的 A2 后一个字节）178h 的 A2 为止，进入不同分支
if (当前字节 = dh) {
	[D024] += 1
}

这个 A2 使得 [D024] = 2
根据 MSG06.MES 推测，接下来进入 1A2 的 A3，触发 [D024] -= 1
当前 A2 对应 9178，那么下次 A3 对应 (1A2 - 178) + 9178 = 91A2
这时 [D024] = 1

接下来有可能访问 1F8 的 A2 或 20C 的 A3，对应 91F8 或 920C
结果读入 A2，[D024] += 1
这时 [D024] = 2

最后在 9739 处停下来，说明 A3 达到可以让 [D024] 降 0 的量
对应 MSG06.MES 的 739

AB 81 6F CD 29 02 00 22 41 20 31 22 CD 29 02 00 22 4F 20 30 2C 50 20 30 20 31 31 20 33 31 33 32 BC
AB 等待输入
81 6F (
CD	进入分支1.2.6.4，函数表，在 27 号函数，先执行 53684()，读后一个字节 29，最后得到 AX = 0100
		不知为什么指针 + 3，当前指针指向 22，然后不断找到下一个 22，指针 + 1
	AB 81 6F (CD) (29) 02 00 22 41 20 31 22 CD 29 02 00 22 4F 20 30 2C 50 20 30 20 31 31 20 33 31 33 32 BC
	AB 81 6F CD 29 02 00 (22) 41 20 31 22 CD 29 02 00 22 4F 20 30 2C 50 20 30 20 31 31 20 33 31 33 32 BC
	AB 81 6F CD 29 02 00 22 41 20 31 (22) CD 29 02 00 22 4F 20 30 2C 50 20 30 20 31 31 20 33 31 33 32 BC
	AB 81 6F CD 29 02 00 22 41 20 31 22 (CD) 29 02 00 22 4F 20 30 2C 50 20 30 20 31 31 20 33 31 33 32 BC

CD 29 02 00 22 41 20 31 22
CD 29 02 00 22 4F 20 30 2C 50 20 30 20 31 31 20 33 31 32 22
BC A2 10 02 00
81 97
BC A2 08 01 08 02
81 97
CD 29 17 00 22 43 6F 70 79 20 41 ...... 22

我知道了！之所以要 22 开始到 22 结束，是因为 22 = "，这是在读取字符串为参数，两个 22 代表起止点
CD 之后遇到 29，29 跳 3 个字节到 22 开始字符串，再到 22 结束字符串，中间是 ascii 解析
=> CD 29 02 00 (22 41 20 31 22) => "A 1"
=> CD 29 02 00 (22 4F 20 30 2C 50 20 30 20 31 31 20 33 31 32 22) => "O 0,P 0 11 312"

=====================================================================================================
猜想1
	CD 对应的正则规律是 \xCD\x29[\s\S]{2}\x22[^\x22]+\x22
正确的例子，CD 29 02 00 22 ... 22
猜想不完整，例外是 CD 29 30 50 28 0B 29 02 38 28 44 29 03 0F
		   CD 29 50 40 23 2A 62 30
	更新猜想，CD 后的字节分成 [23, 27] => 1 个字节，28 => 2 个字节，[29, 2C] => 3 个字节三种
	不属于这三者的就结束解析，特别地，中间如果出现 22 ... 22 就优先结束
	因此
	CD 对应的正则规律是
		\xCD([\x29-\x2C][\s\S]{2}|\x28[\s\S]|[\x23-\x27]){1,}(\x22[^\x22]+\x22){0,1}


CD 跳三个字节，如果是 22 的话，那么就到下一个 22 结束
或者说，CD 下一个字节遇到 29，那么 29 会跳过自身在内三个字节，如果这时读到 22，就会延续到下一个 22
读到 28
读到 23
读到 28，跳包括自己 2 个字节，遇到 29，跳 3 个字节，遇到 28，跳 2 个字节，遇到 29
读到 23，跳 1 个字节 2A

CD 的逻辑再分析	（以 CD 29 30 50 28 0B 29 02 38 28 44 29 03 0F 为例）
CD 对应的是函数表 (CD - A6) = 27h 号函数
进入函数，会先调用 53684()
53684() 的逻辑，会读下一个字节，并分类 [23, 27], 28, [29, 2C] 与其它
CD 29，读到 29
	因此进入 [29, 2C] 的处理逻辑，代码位置 536AA
	这个分支下，会再读一个 word 3050 => CH = 30 Cl = 50，指针 + 2
	把 CH 称为第一字节，CL 为第二字节，后续是第一字节除以 2，第二字节 * 2 再循环右移
	第一字节 30 / 2 => 18，因为 30 的最右边是 0，所以 CF = 0
	第二字节 50 * 2 => A0 循环右移 => 50，因为 CF = 0 所以循环后最左边补 0

	盘一下这个逻辑 CH CL 是两个八进制数 12345678 12345678
	右边的乘以 2，就是 12345678 23456780
	左边的除以 2，就是 01234567 8 23456780
	右边的循环右移，是 01234567 82345678
	所以 30 50 => 18 50
	本质上是左边除以 2，右边根据左边的最右二进制位修改最左二进制位
	至此，解释了 CD 29 30 50 为什么 29 要带包括自己 3 个字节

	AL = (AL - 29) * 7，也就是 (29 - 29) * 7，这里是 00
	AH = AL
	AL = 00，即 AX = ((Param - 29) * 7, 00) => 0000
	AX = AX + CX	这里 CX = (CH, CL) = 1850，所以 AX = 1850

	临时换个例子 CD 29 50 40
	AX = ((29 - 29) * 7, 00) = 00 00
	CX = (50 40) => 28 40
	AX = 2840

	把 AX = 1850 存到 [DD9D]
	...
	比较下一字节 28 和 22，这很明显是 "..." 模式的搜索逻辑，这里如果匹配了就会进入 "..."
	但是这里 28 不匹配，所以才造成了例外情况
	
小结论：CD 后的 29，29 是进入 [29, 2C] 分支处理，会读一个 word，处理后存入 [DD9D]，即 CD 29 (XX XX)

	28 不是 22，那么
	call 53684()，又是这个函数，和刚才详细解释的流程一样
	53684 分为 [23, 27], 28, [29, 2C] 和其它四种分支处理，返回值是 0 或 1，会在 ZF 提供
	28 命中 28 分支
		会再读一个字节，CD 29 30 50 28 0B 29 02 38 28 44 29 03 0F，对应 0B
		AX = (00 0B)
		return 1
	把 AX = 000B 存入 [BX]
	跳回 53307，进行 "..." 模式识别，判断后续字节是否 22，这里 28 0B 后是 29，不匹配
	不匹配就又跳入 5331B，call 53684()
	29 读到 (02 38) => (01 38)，29 本身 => ((29 - 29) * 7 00)，相加得 01 38，存入 [BX]
	return 1
	
	只要 return 1，就会不断进行 22 的 "..." 模式识别，识别不出来就重复 53684() 分支判断

小结论：CD 里的 28，28 是再读一个字节，构造 AX = (00 XX)

	下一字节是 28，28 分支读取 44，目前为止
	CD (29 30 50) (28 0B) (29 02 38) (28 44) 29 03 0F
	接下来读到 29，对应 (03 0F) => (01 8F)，与 (00 00) 相加得 AX = (01 8F)，return 1
	CD (29 30 50) (28 0B) (29 02 38) (28 44) (29 03 0F)
	后续是 CD 29 02 00 22 45 22

	接下来读到 CD，CD 在 53684() 里的 [29, 27], 28, [29, 2C] 之外的分支
	AX = FFFF，return 0，所以退出了循环

=====================================================================================================

BC 规律未知，函数表的 0x16 号函数，观察到的情况有两种
BC A2 10 02 00
BC A2 08 01 08 02

81 97 是特殊的 sjis 字节，goto 52626

CF 23 23 28 0B 29 02 38
CD 29 17 00 22 43 6F 70 79 20 41 3A 5C 52 42 5F 50 41 52 54 53 5C 43 4F 4D 5F 57 49 4E 33 2E 47 50 43 2C 47 50 43 22
CF 23 23 28 0B 29 02 4E
A4 ......

CF 对应执行 0x29 号函数
CF 23 23 28 0B 29 02 38
CF 23 23 28 0B 29 02 4E

A4 对应分支 2，属于 [A0, A4] 的一种，从 7C7 开始，下一次来到 9B3，规律是遇到第一个 A3 结束，9B2 是 A3，因此来到 9B3
9B3 又是 A4，它的后续第一个 A3 在 AAA，因此跳到 AAB，读取 BC

=====================================================================================================
猜想2
	A4 对应的规律是：直到后续第一个 A3 为止
	正则表达式：\xA4[^\xA3]+\xA3
=====================================================================================================

BC A2 10 02 00
81 97
A7 28 0C 29 02 3C
BC A2 10 00 00
81 97
81 77 81 63 81 63 32 77 41 30 56 2E 81 78
A4 10 00 01 81 97 81 77 81 63 81 63 96 B3 ... A3

A7 对应分支1.2.6.4，走函数表 1 号函数，最终会调用 int(F6, AH = 05)，过程中调了 2 次 53684()，每次指针 += 3

BC 对应 0x16 号函数，地址 5303C
BC A2 10 00 00
BC 读取的时候，因为大循环是读 2 个字节为 word，所以指针指向 10，这时 16 号函数进来又读一个字节并指针 += 1
所以，16 号函数里的 call 52BF9 读 1 个字节 10（相对于 BC 的后个字节）
比较这后个字节是否等于 A3 或 A4，是则跳到另一处，否则再指针 + 1 读大后个字节 00，然后又指针 + 1
经过这两步后，AH = 10,AL = 00，对应 BC A2 (10 00) 00
然后判断 AH 是否符合 0X 模式，1X 模式，分别进入 52C35 和 52C46 处理，否则指针 - 2
本例，10 符合 1X 模式，跳入 52C46
52C46：call 536EF，这个函数执行后指针 + 1

这里我猜测 8197 其实是选项文本的开始？确实有一个选项文本在 8197 后开始，地址是 ABD

A7 28 0C 29 02 51
BC A2 08 01
81 97
81 77 81 63
81 63 8F AD 43 81 41 96 D9 4F 52 30 52 3B 78 56 30 37 81 78
A4 0C 01 81 97 81 77 49 78 5B 81 41 49 78 5B 81 63 81 63 81 78 A3
BC A2 08 01 08 02
81 97
A4 0C 01 08 02 81 97 A7 28 0C 29 02 66 81
77 49 32 30 34 5C 81 63 81 63 92 A9 83 81 83 56
81 41 6A 4C 90 48 4F 52 30 56 37 4F 4B 81 78 A4
08 01 0C 02 81 97 A7 28 0C 29 02 66 81 77 43 73
32 38 56 30 56 2E 81 63 81 63 81 78 A4 0C 01 0C
02 81 97 A7 28 0C 29 02 66 81 77 43 73 32 38 56
30 56 2E 81 63 81 63 81 78 A7 28 0C 29 02 7B 81
77 49 32 30 34 5C 81 63 81 63 92 A9 83 81 83 56
81 41 6A 4C 90 48 4F 52 30 56 37 4F 4B 81 78 A3

BC 的特性，是跳一个字节读 1 个 word，除非跳一个字节后，读的第一个字节是 A3 或 A4，此时会另外处理
比如 BC A2 10 00 00，对应读取 BC A2 (10 00)
比如 BC A2 08 01，对应读取 BC A2 (08 01)
注意到 08 符合 0X 模式，进入 52C35
52C35: call 536D3，这个函数执行后指针不变
然后循环读取下一个 word，81 97，发现它首字节不是 A3 或 A4，也不符合 0X, 1X 模式，猜测这里回退并退出

比如 BC A2 08 01 08 02，就是 08 01 命中一次 0X 后再命中一次 0X，所以是 2 + 2

=====================================================================================================
猜想3：
	BC 对应的规律是，隔一个字节读一个 word，如果读到的首字节不是 A3 与 A4
	那么如果是 0X，跳 2 个字节，如果是 1X，跳 3 个字节，否则结束，循环
比如 BC A2 (10 00 00)，后续 81 97 不符合，终止
比如 BC A2 (08 01)，后续 81 97 不符合，终止
比如 BC A2 (08 01) (08 02)，后续 81 97 不符合，终止

	\xBC[\s\S]([\x00-\x0F][\s\S]|[\x10-\x1F][\s\S]{2})
=====================================================================================================

能打印指针和字节的快捷断点
bp 52666,,{ printf "SI=%04X => AL=%02X",esi&0xFFFF,eax&0xFF}

遇到意外的 CD 解析
CD 29 30 50 28 0B 29 02 38 28 44 29 03 0F
CD 29 50 40 23 2A 62 30
CD 29 6B 40 28 65 28 58 29 02 3B 29 04 27 29 02 62

0F 是 0X 模式，读两个字节包括自己在内
比如
...
0F 87
...

=====================================================================================================
猜想4：
	0X 总是带一个字节
	正则匹配：[\x00-\x0F][\s\S]
=====================================================================================================

BB A2 0F 87
81 97
C5 23 28 10
C5 24 28 10
CD 29 50 40 24 23 24 24 26 29 07 06 A3 A4 0C 01 08 02
81 97 CD 29 6B 40 28 65 28 58 29 02 3B 29 04 27
29 02 77 81 97 0F 87 81 97 BB A2 0F 87 81 97 C5
23 28 10 C5 24 28 10 CD 29 50 40 24 23 24 24 27
29 07 06 A3

BB 也是函数表模式，对应 0x15 号函数
BB A2 0F 87
81 97

C5 应该是函数表模式
C5 23 28 10
C5 24 28 10

CD 这里执行后选项等待选中



MSG00.MES 的拆解
所有 MAME 模拟器的 9XXX 都可以直接翻译为 MES 文件的 XXX 地址
CE 23 23
CE 24 24
B7 26 23 23 25 23 28 10
C5 23 28 10
C5 24 28 10
CD 29 02 00 22 41 20 31 22
CD 29 02 00 22 4F 20 30 2C 50 20 30 20 31 31 20 33 31 32 22
CD 29 02 00 22 41 20 30 22
CD 29 30 50 28 0B 29 02 38 28 44 29 03 0F
CD 29 02 00 22 45 22
CD 29 02 00 22 49 22
BC A2 10 2C 00
81 97
A4 D0 25 A3
BC A2 10 00 00 81 97 ...... A4 10 00 01 (548 个字节)	这里猜测只读到 BC A2 10 00 00，然后在其它地方循环处理
81 97
CD 29 02 00 22 41 20 31 22
CD 29 17 00 22 43 6F 70 79 20 41 3A 5C 52 42 5F 50 41 52 54 53 5C 47 5F 45 52 41 53 45 52 2E 47 50 43 2C 47 50 43 22
CF 23 23
CD 29 02 00 22 41 20 30 22
CD 29 30 50 28 05 23 28 4A 29 02 42
CD 29 02 00 22 41 20 31 22
C9 22 42 3A 5C 52 42 5F 47 50 43 5C 52 42 5F 30 30 2E 47 50 43 22
CF 23 26
C9 22 42 3A 5C 52 42 5F 47 50 43 5C 52 42 5F 30 30 42 2E 47 50 43 22
CF 24 26
C1 23 22 41 3A 5C 52 42 5F 47 50 41 5C 52 42 5F 30 30 42 2E 47 50 41 22
C1 24 22 41 3A 5C 52 42 5F 47 50 41 5C 52 42 5F 30 30 42 2E 47 50 41 22
CD 29 17 00 22 43 6F 70 79 20 41 3A 5C 52 42 5F 50 41 52 54 53 5C 47 5F 46 52 41 4D 45 30 2E 47 50 43 2C 47 50 43 22
CF 23 23
CD 29 17 00 22 43 6F 70 79 20 41 3A 5C 52 42 5F 50 41 52 54 53 5C 47 5F 46 52 41 4D 45 31 2E 47 50 43 2C 47 50 43 22
CF 23 23
CD 29 17 00 22 43 6F 70 79 20 41 3A 5C 52 42 5F 50 41 52 54 53 5C 47 5F 46 52 41 4D 45 32 2E 47 50 43 2C 47 50 43 22
CF 23 23
CD 29 02 00 22 41 20 30 22
CD 29 30 50 28 05 23 28 4A 29 02 42
C2 23 22 ... 22 (72 个字节，猜测 22 ... 22 为范围)
C2 24 22 ... 22 (72 个字节)
CD 29 02 00 22 47 20 30 20 31 31 20 33 31 32 20 35 38 20 38 38 22
CD 29 3F 40 28 0B 28 27 28 3A 28 0B 26 23 23
A6 28 0C 29 02 3C 28 43 29 03 0A
AA 23		(对话框开始的标志，清理对话框)
C5 23 28 10
C3 24 2C 7F 7F
88 A4
89 B9
81 71
81 63
81 63
81 63
81 63
40
6D
7F
59
81 72
A5
81 A2
AB		（等待 UI 的标志）

从上面又可以提出一些猜测
=====================================================================================================
猜想5：
	CE/CF 总是带 2 个字节
	[\xCE\xCF][\s\S]{2}
=====================================================================================================

SI=9000 => AL=CE
SI=9003 => AL=CE
SI=9006 => AL=B7
SI=900A => AL=C5
SI=900E => AL=C5
SI=9012 => AL=CD
SI=901B => AL=CD
SI=902F => AL=CD
SI=9038 => AL=CD
SI=9046 => AL=CD
SI=904D => AL=CD
SI=9054 => AL=BC
SI=905C => AL=D0
SI=905E => AL=A3
SI=905F => AL=BC
SI=9064 => AL=81
SI=9066 => AL=D1
SI=9069 => AL=A6
SI=9071 => AL=AA
SI=9073 => AL=D1
SI=9075 => AL=CD
SI=9084 => AL=A6
SI=908F => AL=AA
SI=9091 => AL=A7
SI=9097 => AL=81
SI=9099 => AL=81
SI=909B => AL=81
SI=909D => AL=81
SI=909F => AL=81
SI=90A1 => AL=81
SI=90A3 => AL=81
SI=90A5 => AL=81
SI=90A7 => AL=81
SI=90A9 => AL=81
SI=90AB => AL=21
SI=90AE => AL=81
SI=90B0 => AL=81
SI=90B2 => AL=8C
SI=90B4 => AL=8D
SI=90B6 => AL=81
SI=90B8 => AL=81
SI=90BA => AL=CD
SI=90C3 => AL=C9
SI=90DD => AL=CF
SI=90E0 => AL=C9
SI=90F6 => AL=CF
SI=90F9 => AL=CD
SI=9120 => AL=CF
SI=9123 => AL=CD
SI=914A => AL=CF
SI=914D => AL=CD
SI=9174 => AL=CF
SI=9177 => AL=BC
SI=917F => AL=81
SI=9181 => AL=10
SI=9184 => AL=81
SI=9186 => AL=C0
SI=91A0 => AL=C0
SI=C006 => AL=C5
SI=C00A => AL=C5
SI=C00E => AL=BC
SI=C02F => AL=81
SI=C031 => AL=D0
SI=C047 => AL=A4
SI=C128 => AL=81
SI=C12A => AL=0F
SI=C12C => AL=81
SI=C12E => AL=D4
SI=91A2 => AL=A3
SI=91A3 => AL=CD
SI=91B9 => AL=CD
SI=91D8 => AL=CD
SI=91E1 => AL=CD
SI=91EC => AL=A6
SI=91F7 => AL=BC
SI=9200 => AL=81
SI=9202 => AL=D0
SI=9204 => AL=D0
SI=9206 => AL=81
SI=9208 => AL=0B
SI=920A => AL=81
SI=920C => AL=A3
SI=920D => AL=AB

BC 的 OP 分析，对应 BC - A6 = 16，调用 16 号函数，地址 5303C
案例 BC A2 10 2C 01 81 97 A4 D0 25 A3

call 52BF9
	因为 52666 读的是 word BC A2，所以天然隔一个字节
	隔 A2 读后一个字节 10，判断是否为 A3 或 A4，是则进入 52C2F	AH = 10
	现在 10 不是 A3 或 A4，所以继续
	再读下一个字节 2C						AL = 2C
	判断第一次读的字节 10 是否满足 0X 模式，进入一个分支 52C35，是否满足 1X 模式，进入另一个分支 52C46
	这里满足 1X 模式，所以进入 52C46
	
	52C46 的逻辑（BC XX 1X）
	call 536EF
		读下一个字节 01
	...
	call 53717
		读下一个字节 81
		判断所读字节 81 是否等于 A4，不是则再判断是否等于 A2，不是则再判断是否等于 A3
		81 不等于 A4,A2,A3，那么指针回退
		call 53773
		后续似乎回到熟悉的地方，在做 81 97 的 sjis 解析
		然后读到 81 97 得下一个字节 A4，判断是 A4 就返回
	判断当前指针前一个字节是否为 A3，是则顺序走，否则来到 5303E
	这里指针前一个字节是 A4，不满足，所以跳到 5303E，这个地址是一个循环，是 16 号函数的循环，从 call 52BF9 继续

	至此可知 16 号函数是一个 while 循环
	while() {
		call 52BF9
		if (满足条件) return
	}
	
	这里在循环的 52BF9() 里，继续读下一个字节 D0 和 25，因为首字节 D0 不是 A3 或 A4，不会进入其它分支
	然后 D0 也不符合 0X 或 1X 模式，指针回退 2，重新指回 D0 25 之前
	BC 的分段处理结束

案例 BC A2 10 02 00 81 97 D1 23
答案 BC A2 10 02 00
断点 bp 5303C，此时 SI 指向下一字节，AL 是 BC 后的一个字节

读取 BC，隔 A2 进入 16 号函数 5303C
第一字节是 10，第二字节是 02
10 不符合 A3, A4，符合 1X 模式，因此走 3 个字节 10 02 00
经过 536EF 后，ah === 0, ch === cl，所以 continue，继续读 2 个字节 81 97
81 不符合 A3, A4, 0X, 1X 模式，所以回退 2 个指针，令 al = 0 并 return
外层的函数看到 al = 0，也 break 直接 return
所以 BC A2 10 02 00 结束

function 5303C() {
	si++
	push si
	do {
		52BF9()
		if (al === 0) break
		if ([si - 1] === 0xA3) break
	} while (true)
	pop si
	dx = A2A3
	53652()
	return
}

// 这个函数里的 break 会在 5303C 继续循环，只要不是 A3 结尾，但这时的指针已经不是原来的指针
function 52BF9() {
	while (true) {
		ah = [si]
		if (ah === A3 || ah === A4) {
			break
		}
		si++
		al = [si]
		si++
		if (ah match 0X) {
			536D3()  // 可能会改 bx
			if ([bx] === 0xd) continue
			break
		}
		if (ah match 1X) {
			536EF()  // 会改变 ah，ch, cl 作为返回值，其中 ch 是接着下字节，这就是 1X 多读一个字节的原因

			if (ah === 0) {
				if (ch === cl) continue
				break
			}
			if (ah === 2) {
				if (ch <= cl) continue
				break
			}
			if (ah === 4) {
				if (ch >= cl) continue
				break
			}
			if (ch !== cl) continue
			break
		}

		si -= 2
		push cx
		push dx
		mov cx, [D00A]
		mov dx, [D00C]
		int (F6, ah = 5)
		pop dx
		pop cx

		52626()
		al = 0
		return
	}
	53717()	  // 实测 53717 这个函数可能会修改指针
	al = FF
	return
}

function 536EF() {
	ch = [si]
	si++

// 此时，ah 是第 1 字节，al 是第 2 字节，ch 是第 3 字节
	if (al 是奇数) {
		ch = ch | 0x80
	}
	if (ah 是奇数) {
		ch = [ch + 80]
	}

	bx = ax & 0x7E	// 0111 1110
	bx /= 2		// 这两句就是掐头去尾摆右边
	bx += 0x80
	cl = [bx]

	ah = ah & 0x0E	// 0000 1110
	return
// 后面主要看 ah 的值是否为 0/2/4，ch 和 cl 的大小关系
}
	
文字的结束不一定是 AB 结束
参考
AA 23
A7 28 0C 29 02 5A
81 40
81 40
81 40
81 40
81 40
81 40
81 40
81 40
81 40
81 40
21 20 00
81 73
81 5C
8C BB
8D DD
81 5C
81 74
CD 29 02 00 22 41 20 31 22
C9 22 41 3A 5C 52 42 5F 50 41 52 54 53 5C 46 52 41 4D 45 5F 30 2E 47 50 43 22

它在文字结束后并没有马上跟着 AB，而是 CD
	
『……うるさいなあ』（1 个孩子）
	『……無視、ムシ』（1 个孩子）
		『そんなこと……オレは、頼んだ憶えがない』（2 个孩子）
			『……もう、帰れよ』=> 选后不变（叶子）
			『しょうがないなあ……』 => 选后新场景

『しょうがないなあ……』=> 选后新场景（2 个孩子）
	『いいかげんにして、もう帰れよ――美夏』（1 个孩子）
		『まったく……困ったお嬢さまだな』
	『美夏――お嬢さまなら、お嬢さまらしくしていろよ』

『……少し、黙っていてくれないか』（2 个孩子）
	『それは、それは……』=> 选后不变（叶子）
	『そういえば……朝メシ、まだ食っていなかった』=> 选后不变（叶子）


选项文本区
28 0B 29 02 63 A3 BC A2 10 02 00 81 97 A7 28 0C 29 02 3C BC

A2 10 00 00 81 97

『……うるさいなあ』（1c）
A4 10 00 01 81 97

『……無視、ムシ』（1c）
A4 10 00 02 81 97

『そんなこと……オレは、頼んだ憶えがない』(2c)
A4 10 00 03 81 97

『……もう、帰れよ』(loop)
A3 A7 28 0C 29 02 51 BC A2 08 01 81 97

『……少し、黙っていてくれないか』(2c)
A4 0C 01 81 97

『それは、それは……』(loop)
A3 BC A2 08 01 08 02 81 97 A4 0C 01 08 02 81 97 A7 28 0C 29 02 66

『そういえば……朝メシ、まだ食っていなかった』
A4 08 01 0C 02 81 97 A7 28 0C 29 02 66

『しょうがないなあ……』
A4 0C 01 0C 02 81 97 A7 28 0C 29 02 66

『しょうがないなあ……』
A7 28 0C 29 02 7B

『そういえば……朝メシ、まだ食っていなかった』(loop)
A3 A4 10 02 01 81 97 A7 28 0C 29 02 3C BC A2 08 01 81 97

『いいかげんにして、もう帰れよ――美夏』
A4 0C 01 81 97

『まったく……困ったお嬢さまだな』
A3 A7 28 0C 29 02 51

『美夏――お嬢さまなら、お嬢さまらしくしていろよ』
A4 10 02 02 81 97 BC A2 08 05 81 97 A7 28 0C 29 02 3C BC A2 08 01 81 97

『美夏は……オレに、惚れているのか？』
A4 0C 01 81 97

『おじいさま……ねえ』
A3 A4 0C 05 81 97 81 97 A3 BC A2 08 05 81 97 A7 28 0C 29 02 51 A4 0C 05 81 97 A7 28 0C 29 02 3C A3 BC A2 10 00 00 81 97

『誰か来たようだ……』
A4 10 00 01 81 97

『美夏、ちょっと出てみてくれないか』
A4 10 00 02 81 97

『ひょっとしたら、美夏に用事かも知れないゾ』
A4 10 00 03 81 97

『しつこいなあ……あきらめて、帰ればいいのに』
A3 BC A2 08 05 81 97 A7 28 0C 29 02 66 A4 0C 05 81 97 A7 28 0C 29 02 51 A3

『美夏――望み通り、見てやるゼ！』
BC A2 08 05 81 97 81 97 A4 0C 05 81 97 A7 28 0C 29 02 66

『――押売、勧誘ならお断わりだ！』
A3 A3


AA 23 文本 AB 是大多情形

但有 AA 23 文本 其它OP 的情形，不以 AB 结尾，比如
「――悠、こちらをごらんなさい」 A4 10 02 01 81 97 BC A2 0F 8A 81 97 A4 0B 8A 81 97
游戏中这句话之后显示选项

也有
AA 23 非文本 文本 AB 的情形
比如
AA 23
C5 23 28 10 C5 24 28 10 
愛音〈……………………〉
▽
▽
▽

AB

AA 23
C5 23 28 10 C5 24 28 10 
愛音〈…………………悠〉
△
AB


C5 似乎是带三个字节
C5 23 28 10
C5 24 28 10
这样
研究了一下 C5 属于调用函数表的类型，编号 1F，对应 531FB 函数
调用两次 53684 函数
53684 是按 [23, 27], 28, [29, 2C] 和其它处理的函数
- 其它分支下，return 0，不读字节
- [23, 27]，处理这个字节本身，return 1		SI += 1
- 28，再读 1 个字节, return 1			SI += 2
- [29, 2C]，读 1 个字节, return 1		SI += 1
然后调用两次 int F3 常数

这里 C5 进去
第 1 次读取 23，读 1 个字节 23，过
第 2 次读取 28，读 2 个字节 28 10，结束

AA 23
C5 23 28 10
C3 24 2C 7F 7F
对话
AB

这里还有一种 C3 24 2C 7F 7F 情形

C3 属于调用函数表，编号 1D，对应 531D5 函数
也是调 2 次 53684 函数，然后返回
第 1 次读 24，属于 [23, 27]，读 1 个字节 24，过
第 2 次读 2C，属于 [29, 2C]，读 1 个字节 2C，过	但实际上读了 3 个字节 2C 7F 7F

=====================================================================================================
结论4：
	OP = C5 或 C3，对应 1F 号函数，531FB
	逻辑是做两次以下处理：
		23-27，过 1 个字节
		28，过 2 个字节
		29-2C，过 3 个字节（准确讲，当前字节外读 2 个字节(1 个 word)）
	正则：
		[\xC3\xC5]([\x23-\x27]|\x28[\s\S]|[\x29-\x2C][\s\S]{2}){2}
=====================================================================================================


还有一种
AA 23
D0 73 65 24 
《‥ピンポ～ン‥》
△

D0 是什么 OP? 经过拆解是 D0 73 65 24

D0 也是函数调用表，编号 2A，函数入口 533C3
MSG06.MES 的 709 或 19C6
案例 D0 73 65 24

D0
	D0 73 65 的情况:
	找到后续第一个不是 0x20 的字节
		如果是 0x22 则读取字节直到下一个 0x22 结束
		\xD0\x73\x65(\x20){0,}\x22[^\x22]+\x22
		不是 0x22 则调用 53684() 分为 [23,27],28,[29,2C],其它处理
		\xD0\x73\x65(\x20){0,}[^\x22]([\x23-\x27]|\x28[\s\S]|[\x29-\x2C][\s\S]){0,1}
	总结为
		\xD0\x73\x65(\x20){0,}(\x22[^\x22]+\x22|[^\x22]([\x23-\x27]|\x28[\s\S]|[\x29-\x2C][\s\S]){0,1})
	


proc 533C6(OP = D0)
	ax = 当前word，这里读入 AX = 65 73
	ax |= 2020h
	if (ax === 6573) {
		指针 += 2	// 因为读了 2 个字节 65 73 所以指向下一字节
		do {
			lodsb	// 从 DS:SI 读一个字节到 AL
		} while (al === 0x20)
		指针 -= 1

		if (al === 0x22) {
			指针 += 1
			di = DC8D
			53804()		// 循环读取字节处理，直到再遇 0x22 结束
			bx = di
			int(F4, ah=10)
			return
		} else {
			53684()		// 53684() 读取下一字节 [23, 27], 28, [29, 2C] 或其它
			bx = ax
			int(F4, 11)
			return
		}
	}
	if (当前字节 === 0x22) {
		指针 += 1
		di = DC8D
		53804()
		int(F4, ah=2)
		bx = DC8D
		int(F4, ah=0)
		return
	}
	53684()
	ax -= 1
	if (ax === 0) {
		53684()
		if (返回值 === 0) {	// 即 53684() 读取的下一字节不在 [23, 27], 28, [29, 2C] 内
			if (ax <= 0x80) {
				ax -= 0x40
				cx = ax
				int(F4, ah=2)
				int(F4, ah=7)
				return
			}
			ax = 0x80-0x40
			cx = ax
			int(F4, ah=2)
			int(F4, ah=7)
			return
		}
	}
	ax -= 1
	if (ax === 0) {
		5341B()
		int(F4, ah=3)
		return
	}
	ax -= 1
	if (ax === 0) {
		5341B()
		int(F4, ah=2)
		int(F4, ah=4)
		return
	}
	int(F4, ah=2)
	return


未被解析的情况，MSG07.MES 的
AA 23 BC A2 10 02 00 81 97 81 97 A4 10 02 01 81
97 21 20 00 97 49 21 20 00 81 75 36 8F EC 41 6A
38 81 5C 81 5C 30 4F 4B 30 56 7F 52 83 4A 83 62
83 52 43 52 30 77 7F 4C 81 41 A5 81 40 81 40 81
40 8D E5 8C B4 94 FC 89 C4 81 48 81 76 A5 81 A2
AB

AA 23
BC A2 10 02 00
81 97
81 97
A4 10 02 01
81 97
 悠 「お嬢さまが――いったいなんてカッコしているんだ、
　　　榊原美夏？」
△
AB

第一种情况，前面插入 81 97
第二种情况，前面插入 BC
第三种情况，前面插入 A4

这发生在镜头切换的图像滚动演出前后

SI=91C3 => AL=AA	AA 23
SI=91C5 => AL=BC	BC A2 10 02 00 81 97 81 97 A4 10 02 01
SI=91D2 => AL=81	81 97
SI=91D4 => AL=21	对话开始
。。。
SI=9211 => AL=81	对话结束
SI=9213 => AL=AB	AB

BC 对应 16 号函数，之前已有研究

新的思路，利用 names 对应组合对话符号，思考符号，加上选项符号做成匹配正则「」，〈〉，
[
    '愛音',	88 A4 89 B9
    '山崎',	8E 52 8D E8
    '東山',	93 8C 8E 52
    '菅原',	90 9B 8C B4
    ' 悠 ',	21 20 00 97 49 21 20 00
    '(声)',	21 28 00 90 BA 21 29 00
    '美夏',	94 FC 89 C4
    ' 客 ',	21 20 00 8B 71 21 20 00
    '神緒',	90 5F 8F 8F
    'レポーターＢ',	83 8C 83 7C 81 5B 83 5E 81 5B 82 61
    'レポーターＡ',	83 8C 83 7C 81 5B 83 5E 81 5B 82 60
    'レポーターＣ',	83 8C 83 7C 81 5B 83 5E 81 5B 82 62
    '藤島',	93 A1 93 87
    '恵子',	8C 62 8E 71
    '希子',	8A F3 8E 71
    ' 仁 ',	21 20 00 90 6D 21 20 00
    ' 悠 ・希子',	21 20 00 97 49 21 20 00 81 45 8A F3 8E 71
    '客Ａ',	8B 71 82 60
    '客Ｂ',	8B 71 82 61
    '万里子',	96 9C 97 A2 8E 71
    ' 丈 ',	21 20 00 8F E4 21 20 00
    'ダフ屋',	83 5F 83 74 89 AE
    '親衛隊々長',	90 65 89 71 91 E0 81 58 92 B7
    '親衛隊たち',	90 65 89 71 91 E0 4B 4D
    '梨奈',	97 9C 93 DE
    '守衛',	8E E7 89 71
    '運転手',	89 5E 93 5D 8E E8
    '悠',	97 49
    '司会',	8E 69 89 EF
    '運転手(声)',	89 5E 93 5D 8E E8 21 28 00 90 BA 21 29 00
    '吉川(声)',	8B 67 90 EC 21 28 00 90 BA 21 29 00
    '吉川',	8B 67 90 EC
    '神緒・美夏',	90 5F 8F 8F 81 45 94 FC 89 C4
    '神緒・美夏・梨奈・恵子・希子'	90 5F 8F 8F 81 45 94 FC 89 C4 81 45 97 9C 93 DE 81 45 8C 62 8E 71 81 45 8A F3 8E 71
]

目前汉化遗留的问题：
1. 换行符后面的空格数没有完全对齐，猜测应该根据 name 的长度计算调整
2. 选项的『 』符号没有检查对齐，或者在翻译前预处理掉

hdi 文件替换研究
用的是 FAT 规范，参考之前的 FAT 笔记
104840 开始的 3104 个字节是 RB_MES 的目录项
每 32 字节一个文件

文件抽取：
- hdi 文件路径
- 引导区开始地址
- 文件起始簇号
- 文件大小
- 输出文件名
python extract_fat_file_with_offset.py "J:\PC98 Files\Bay City Elegy.hdi" 0x9400 0xFD 0x71E MSG00.mes


替换 hdi 里被修改的子文件的命令
python replace_hdi_file.py "J:/PC98 Files/Bay City Elegy_CN.hdi" 0x9400 "//YOKOHAMA/RB_MES/MSG01.MES" "./RB_CN_MES/MSG01.MES"

node replaceHdiFile.js  "J:/PC98 Files/Bay City Elegy_CN.hdi" 0x9400 "//YOKOHAMA/RB_MES/MSG01.MES" "./RB_CN_MES/MSG01.MES"

剩余问题：
1. 演唱会
2. 部分未翻译文本,一些地名
3. 文本润色

对应的应该是 RB_STAG1.MES，RB_STAG2.MES，RB_STAG3.MES，RB_STAG4.MES
MSG37.MES, MSG61.MES

MSG24.MES 有
《―イセザキ町―》
81 73 81 5C 83 43 83 5A 83 55 83 4C 92 AC 81 5C 81 74

MSG31.MES 有
《―‘フィオリーナ’―》
81 73 81 5C 81 65 83 74 83 42 83 49 83 8A 81 5B 83 69 81 66 81 5C 81 74

MSG25.MES
MSG26.MES
MSG27.MES
MSG57.MES
《‥ガランガラン‥》
81 73 81 64 83 4B 83 89 83 93 83 4B 83 89 83 93 81 64 81 74

之前的正则搜索漏了一种 《》的情形
